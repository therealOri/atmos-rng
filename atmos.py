import os
import requests
import re
import base64


def clear():
    os.system("clear||cls")





def randint(minimum, maximum, num=1):
    url = f"https://www.random.org/integers/?num={num}&min={minimum}&max={maximum}&col=5&base=10&format=plain&rnd=new"
    #random numbers generated by atmospheric noise. (as close to random as one can get while not having to use math.)
    response = requests.get(url)
    if response.status_code == 200:
        if num > 1:
            numbers_list = re.split(r'[\n\t]+', response.text.strip())
            return numbers_list
        else:
            return int(response.text)
    else:
        raise ValueError(f"\nRequest to random.org failed with status code: {response.status_code}. Unable to generate random number.")


#NOTE
#https://stackoverflow.com/a/65499571/15114290  |  True == 1 when working with sets.
#Sets are also ordered from boolean, ints, strings
def choice(list_of_data):
    maximum = len(list_of_data)-1
    #for example lets say "list_of_data" is 11 items long, we need to account for index 0, 0 is the minimum so now there are 10 index spots to choose from, not 11.
    #we will get an "index out of range" error without "-1".
    index = randint(0, maximum, 1)

    #List
    if isinstance(list_of_data, list):
        list_option = list_of_data[index]
        return list_option

    #Dictionary
    elif isinstance(list_of_data, dict):
        keys = list(list_of_data.keys())
        selected_key = keys[index]
        selected_value = list_of_data[selected_key]
        selected_dict = {selected_key: selected_value}
        return selected_dict #type dictionary

    #Tuple
    elif isinstance(list_of_data, tuple):
        tuple_option = list_of_data[index]
        return tuple_option

    #Set
    elif isinstance(list_of_data, set):
        set_list = list(list_of_data)
        print(set_list)
        set_option = set_list[index]
        return set_option
    else:
        raise ValueError('\nUnable to make a choice. The data provided is not a list, tuple, set, or dictionary.')





def shuffle(list_of_data):
    if isinstance(list_of_data, list):
        random_numbers = [int(num) for num in randint(0, len(list_of_data)-1, len(list_of_data))]
        for i, j in enumerate(random_numbers):
            list_of_data[i], list_of_data[j] = list_of_data[j], list_of_data[i]
        return list_of_data

    elif isinstance(list_of_data, tuple):
        list_of_data = list(list_of_data)
        random_numbers = [int(num) for num in randint(0, len(list_of_data)-1, len(list_of_data))]
        for i, j in enumerate(random_numbers):
            list_of_data[i], list_of_data[j] = list_of_data[j], list_of_data[i]
        return tuple(list_of_data)

    elif isinstance(list_of_data, dict):
        list_of_data = list(list_of_data.items())
        random_numbers = [int(num) for num in randint(0, len(list_of_data)-1, len(list_of_data))]
        for i, j in enumerate(random_numbers):
            list_of_data[i], list_of_data[j] = list_of_data[j], list_of_data[i]
        return dict(list_of_data)
    else:
        raise ValueError('\nUnable to shuffle data. The data provided is not a list, tuple, or dictionary.')





def gen_bytes(length):
    if not isinstance(length, int):
        raise ValueError(f'\n\nInvalid type, "gen_bytes()" takes type "int", value given is "{type(length)}".')
    else:
        byte_array = bytearray()
        if length == 1:
            for _ in range(length):
                number = randint(0, 255, 1)
                byte_array.append(number)
            return bytes(byte_array)

        elif length > 1:
            list_of_numbers = randint(0, 255, length)
            for number in list_of_numbers:
                byte_array.append(int(number))
            return bytes(byte_array)

        else:
            list_of_numbers = randint(0, 255, 32)
            for number in list_of_numbers:
                byte_array.append(int(number))
            return bytes(byte_array)





def gen_bits(length):
    if not isinstance(length, int):
        raise ValueError(f'\n\nInvalid type, "gen_bits()" takes type "int", value given is "{type(length)}".')
    else:
        if length == 1:
            bit = randint(0, 1, 1)
            result = 0
            result = (result << 1) | int(bit)
            return result

        elif length > 1:
            bits = randint(0, 1, length)
            result = 0
            for bit in bits:
                result = (result << 1) | int(bit)
            return result

        else:
            bits = randint(0, 1, 32)
            result = 0
            for bit in bits:
                result = (result << 1) | int(bit)
            return result




#20 is the default if no argument is passed and the function is just called.
def bytes_urlsafe(length=20):
    if not isinstance(length, (int, type(None))):
        raise ValueError(f'\n\nInvalid type, "bytes_urlsafe()" takes type "int" or "None", value given is "{type(length)}".')
    else:
        if not length:
            length=20 #default if None is provided.
        bytes_to_make_safe = gen_bytes(length)
        urlsafe_token = base64.urlsafe_b64encode(bytes_to_make_safe)
        return urlsafe_token.decode()





if __name__ == '__main__':
    clear()
    print("uwu")

